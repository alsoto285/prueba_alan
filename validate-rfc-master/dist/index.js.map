{"version":3,"file":"index.js","sources":["../src/get-verification-digit.js","../src/index.js"],"sourcesContent":["const VALUES_MAP = {\n  '0': 0,\n  '1': 1,\n  '2': 2,\n  '3': 3,\n  '4': 4,\n  '5': 5,\n  '6': 6,\n  '7': 7,\n  '8': 8,\n  '9': 9,\n  'A': 10,\n  'B': 11,\n  'C': 12,\n  'D': 13,\n  'E': 14,\n  'F': 15,\n  'G': 16,\n  'H': 17,\n  'I': 18,\n  'J': 19,\n  'K': 20,\n  'L': 21,\n  'M': 22,\n  'N': 23,\n  '&': 24,\n  'O': 25,\n  'P': 26,\n  'Q': 27,\n  'R': 28,\n  'S': 29,\n  'T': 30,\n  'U': 31,\n  'V': 32,\n  'W': 33,\n  'X': 34,\n  'Y': 35,\n  'Z': 36,\n  ' ': 37,\n  'Ñ': 38\n};\n\nconst getScore = (string) => string.split('').reverse().reduce((sum, char, i) => {\n  const index = i + 2;\n  const value = VALUES_MAP[char] || 0;\n  return sum + value * index;\n}, 0);\n\nmodule.exports = (input) => {\n  const rfc = input.length === 12 ? ` ${input}` : input;\n  const base = rfc.slice(0, -1);\n  const score = getScore(base);\n  const mod = (11000 - score) % 11;\n  if (mod === 11) return '0';\n  if (mod === 10) return 'A';\n  return String(mod);\n};\n","const getVerificationDigit = require('./get-verification-digit');\nconst forbiddenWords = require('./forbidden-words.json');\nconst validRfcs = require('./valid-rfcs.json');\n\nconst RFC_REGEXP = /^([A-ZÑ\\x26]{3,4})([0-9]{6})([A-Z0-9]{3})$/;\nconst INVALID_FORMAT_ERROR = 'INVALID_FORMAT';\nconst INVALID_DATE_ERROR = 'INVALID_DATE';\nconst INVALID_VERIFICATION_DIGIT_ERROR = 'INVALID_VERIFICATION_DIGIT';\nconst FORBIDDEN_WORD_ERROR = 'FORBIDDEN_WORD';\nconst RFC_TYPE_FOR_LENGTH = {\n  '12': 'company',\n  '13': 'person'\n};\nconst SPECIAL_CASES = {\n  'XEXX010101000': 'foreign',\n  'XAXX010101000': 'generic'\n};\n\nconst parseInput = (input) => {\n  return String(input)\n    .trim()\n    .toUpperCase()\n    .replace(/[^0-9A-ZÑ\\x26]/g, '');\n};\n\nconst validateDate = (rfc) => {\n  const dateStr = rfc.slice(0, -3).slice(-6);\n  const year = dateStr.slice(0, 2);\n  const month = dateStr.slice(2, 4);\n  const day = dateStr.slice(4, 6);\n  const date = new Date(`20${year}-${month}-${day}`);\n  return !isNaN(date.getTime());\n};\n\nconst validateVerificationDigit = (rfc) => {\n  const digit = rfc.slice(-1);\n  const expected = getVerificationDigit(rfc);\n  return expected === digit;\n};\n\nconst hasForbiddenWords = (rfc) => {\n  const prefix = (rfc || '').slice(0, 4);\n  return forbiddenWords.includes(prefix);\n};\n\nconst validate = (rfc, { omitVerificationDigit } = {}) => {\n  if (isSpecialCase(rfc) || isValidCase(rfc)) return [];\n  const errors = [];\n  const hasValidFormat = RFC_REGEXP.test(rfc);\n  const hasValidDate = hasValidFormat ? validateDate(rfc) : true;\n  const hasValidDigit = hasValidFormat ? validateVerificationDigit(rfc) : true;\n  if (!hasValidFormat) errors.push(INVALID_FORMAT_ERROR);\n  if (!hasValidDate) errors.push(INVALID_DATE_ERROR);\n  if (!hasValidDigit && !omitVerificationDigit) errors.push(INVALID_VERIFICATION_DIGIT_ERROR);\n  if (hasForbiddenWords(rfc)) errors.push(FORBIDDEN_WORD_ERROR);\n  return errors;\n};\n\nconst isSpecialCase = (rfc) => rfc in SPECIAL_CASES;\n\nconst isValidCase = (rfc) => validRfcs.includes(rfc);\n\nconst getType = (rfc) => SPECIAL_CASES[rfc] || RFC_TYPE_FOR_LENGTH[rfc.length] || null;\n\nconst getValidResponse = (rfc) => ({\n  isValid: true,\n  rfc,\n  type: getType(rfc)\n});\n\nconst getInvalidResponse = (errors) => ({\n  isValid: false,\n  rfc: null,\n  type: null,\n  errors\n});\n\nmodule.exports = (input, options) => {\n  const rfc = parseInput(input);\n  const errors = validate(rfc, options);\n  const isValid = errors.length === 0;\n\n  return isValid ? getValidResponse(rfc) : getInvalidResponse(errors);\n};\n"],"names":["VALUES_MAP","getVerificationDigit","input","base","length","slice","mod","split","reverse","reduce","sum","char","i","String","forbiddenWords","validRfcs","RFC_REGEXP","INVALID_FORMAT_ERROR","INVALID_DATE_ERROR","INVALID_VERIFICATION_DIGIT_ERROR","FORBIDDEN_WORD_ERROR","RFC_TYPE_FOR_LENGTH","SPECIAL_CASES","validateDate","rfc","dateStr","year","month","day","date","Date","isNaN","getTime","validateVerificationDigit","digit","hasForbiddenWords","prefix","includes","isSpecialCase","isValidCase","getType","options","trim","toUpperCase","replace","parseInput","errors","omitVerificationDigit","hasValidFormat","test","hasValidDate","hasValidDigit","push","validate","isValid","type","getValidResponse","getInvalidResponse"],"mappings":"4OAAA,IAAMA,EAAa,GACZ,IACA,IACA,IACA,IACA,IACA,IACA,IACA,IACA,IACA,IACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,OACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,OACA,OACA,ICvCDC,EDgDW,SAACC,OAEVC,GADuB,KAAjBD,EAAME,kBAAoBF,GAAUA,GAC/BG,MAAM,GAAI,GAErBC,GAAO,KADUH,EATWI,MAAM,IAAIC,UAAUC,QAAO,SAACC,EAAKC,EAAMC,UAGlEF,GADOV,EAAWW,IAAS,IADpBC,EAAI,KAGjB,IAM6B,UAClB,KAARN,EAAmB,IACX,KAARA,EAAmB,IAChBO,OAAOP,ICtDVQ,mSACAC,+EAEAC,EAAa,6CACbC,EAAuB,iBACvBC,EAAqB,eACrBC,EAAmC,6BACnCC,EAAuB,iBACvBC,EAAsB,IACpB,aACA,UAEFC,EAAgB,eACH,wBACA,WAUbC,EAAe,SAACC,OACdC,EAAUD,EAAInB,MAAM,GAAI,GAAGA,OAAO,GAClCqB,EAAOD,EAAQpB,MAAM,EAAG,GACxBsB,EAAQF,EAAQpB,MAAM,EAAG,GACzBuB,EAAMH,EAAQpB,MAAM,EAAG,GACvBwB,EAAO,IAAIC,iBAAUJ,cAAQC,cAASC,WACpCG,MAAMF,EAAKG,YAGfC,EAA4B,SAACT,OAC3BU,EAAQV,EAAInB,OAAO,UACRJ,EAAqBuB,KAClBU,GAGhBC,EAAoB,SAACX,OACnBY,GAAUZ,GAAO,IAAInB,MAAM,EAAG,UAC7BS,EAAeuB,SAASD,IAgB3BE,EAAgB,SAACd,UAAQA,KAAOF,GAEhCiB,EAAc,SAACf,UAAQT,EAAUsB,SAASb,IAE1CgB,EAAU,SAAChB,UAAQF,EAAcE,IAAQH,EAAoBG,EAAIpB,SAAW,aAejE,SAACF,EAAOuC,OACjBjB,EA5DW,SAACtB,UACXW,OAAOX,GACXwC,OACAC,cACAC,QAAQ,kBAAmB,IAwDlBC,CAAW3C,GACjB4C,EAlCS,SAACtB,OAAOuB,0DAA0B,IAA1BA,yBACnBT,EAAcd,IAAQe,EAAYf,GAAM,MAAO,OAC7CsB,EAAS,GACTE,EAAiBhC,EAAWiC,KAAKzB,GACjC0B,GAAeF,GAAiBzB,EAAaC,GAC7C2B,GAAgBH,GAAiBf,EAA0BT,UAC5DwB,GAAgBF,EAAOM,KAAKnC,GAC5BiC,GAAcJ,EAAOM,KAAKlC,GAC1BiC,GAAkBJ,GAAuBD,EAAOM,KAAKjC,GACtDgB,EAAkBX,IAAMsB,EAAOM,KAAKhC,GACjC0B,EAwBQO,CAAS7B,EAAKiB,UACK,IAAlBK,EAAO1C,OAhBA,SAACoB,SAAS,CACjC8B,SAAS,EACT9B,IAAAA,EACA+B,KAAMf,EAAQhB,IAeGgC,CAAiBhC,GAZT,SAACsB,SAAY,CACtCQ,SAAS,EACT9B,IAAK,KACL+B,KAAM,KACNT,OAAAA,GAQyCW,CAAmBX"}